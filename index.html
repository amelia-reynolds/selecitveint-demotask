<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selective Interrogation Task</title>
    <!-- Import Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- Import CSS -->
    <link rel="stylesheet" href="styles.css">
    <link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet'>
    <style>
      body {
        height: 100%;
        margin: 0;
        box-sizing: border-box;
        background-color: #f4f4f9;
        font-family: 'Montserrat', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      h1 {
        font-size: 16px;
        margin: 14px 0px;
      }
      
      p {
        font-size: 14px;
        margin: 14px 0px;
      }

      #instructCont, #alertCont, #labelGrid, #promptCont, #contentCont, #endCont{
        display: none; 
        width: 85%;
        max-width: 1100px;
      }

      #instructCont, #promptCont, #contentCont {
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      #alertCont {
        /* container position */
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        /* container atttributes */
        max-width: 400px !important;
        padding: 0.5vh;
        background-color: #ffffff;
        border: none;
        border-radius: 5px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        /* child attributes */
        font-size: 12px;
        text-align: center;
      }

      #labelGrid {
        /* grid attributes */
        width: 80vw;
        max-width: 1100px;
        height: 80vh;
        margin: 2vh auto;
        /* child attributes */
        display: grid;
        grid-template-columns: repeat(4, 1fr); 
        grid-template-rows: repeat(4, 1fr);    
        gap: 1vw;
      }

      button {
        /* button attributes */
        display: flex;
        justify-content: center;
        align-items: center;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 0.5vh;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        /* button behaviour */
        transition: background-color 0.3s;
        cursor: pointer;
      }

      button:hover {
        background-color: #e0e0e0;
        transform: scale(1.05);
      }

      button:disabled {
        background-color: #f4f4f9;
        border: none;
        box-shadow: none;
        cursor: not-allowed;
      }

      button.start, button.continue, button.end {
        /* button attributes */
        padding: 0.5vh;
        border-radius: 10px;
        border: none;
        /* text attributes */
        text-align: center;
        font-size: 12px;
        font-weight: bold;
        color: #fff;
      }

      button.start { background-color: #00b135; }
      button.continue { background-color: #0065A2; }
      button.end { background-color: #BF2C34; }

      button.label {
        /* button attributes */
        width: 100%;
        height: 100%; 
        padding: 0.5vh;
        border-radius: 3px;
        border: none;
        background-color: #fff;
        /* text attributes */
        text-align: center;
        font-weight: normal;
        color: #000;
      }

    </style>
    <script>

      async function loadStim(csvPath) {// fetch stimuli
        const response = await fetch(csvPath);
        const text = await response.text();
        
        return new Promise((resolve, reject) => {
          Papa.parse(text, {
            header: true,
            skipEmptyLines: true,
            trimHeaders: true,
            complete: (results) => {
              const Stim = { category1: [], category2: [] };
              const categories = [];
              results.data.forEach(row => {// find unique categories
                const category = row.category?.trim(); 
                const label = row.label?.trim();
                const content = row.content?.trim();
                if (category && !categories.includes(category) && categories.length < 2) {
                  categories.push(category);
                }
                if (category === categories[0]) { // assign stimuli to categories
                  Stim.category1.push({ label, content });
                } else if (category === categories[1]) {
                  Stim.category2.push({ label, content });
                }
              });
              console.log("Loaded categories:", categories);
              console.log("Stimuli:", Stim);
              resolve(Stim);
            },
            error: reject
          });
        });
      }

      const usedStim = new Set(); // stored used stimuli
      let gridNum = 0 // store grid number
      let usedLabels = []; // stored selected labels for each grid

      function runIntro() { // run intro
        // display elements
        const intro = document.getElementById('introCont');
        intro.style.display = 'flex';
        // event handling
        document.getElementById('startButton').onclick = async () => {
            try {
              const Stim = await loadStim("stimuli/SelectiveInterrogationTask_Stimuli_FilmStressor.csv");
              window.Stim = Stim;
              console.log("Stimuli loaded:", Stim);
              intro.style.display = 'none';
              gridNum += 1;
              runAlert("The first set of options will now be made available.", 3000, runGrid);
            } catch (err) {
              console.error("Failed to load stimuli:", err);
              alert("Error: Failed to load stimuli.");
            }
        };
      }

      function runAlert(message, duration, callback = null) { // run alert
          // diplay alert
          const alert = document.getElementById('alertCont');
          alert.textContent = message;
          alert.style.display = 'flex;'; 
          // alert duration
          setTimeout(() => {
              alert.style.display = 'none'; 
              if (callback) callback(); 
          }, duration);
      }

      function runGrid() { // run grid
        // grid html
        const container = document.getElementById('labelGrid');
        container.innerHTML ='';
        container.style.display='grid';
        // prompt html
        const prompt = document.getElementById('promptCont');
        prompt.style.display = 'block';
        // shuffle function
        function shuffleStim(array) {
          for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]];
          }
        }
        // subset function
        function getSubset(array, count) {
            const unused = array.filter(item => !usedStim.has(item.label));
            shuffleStim(unused);
            return unused.slice(0, count);
        }
        // select stimuli from pool
        const selectedCategory1 = getSubset(Stim.category1, 8);
        console.log("Category 1 subset:", selectedCategory1);
        const selectedCategory2 = getSubset(Stim.category2, 8);
        console.log("Category 2 subset:", selectedCategory2);
        // ensure sufficient stimuli 
        if (selectedCategory1.length < 8 || selectedCategory2.length < 8) {
          console.warn("Warning: Insuffient stimuli (<16) in pool to populate grid.");
          return; 
        }
        // generate subset ofor grid
        const allSelected = [...selectedCategory1, ...selectedCategory2];
        shuffleStim(allSelected);
        // add stimuli to used list
        allSelected.forEach(option => usedStim.add(option.label)); 
        // populate grid
        allSelected.forEach((option, index) => {
          // generate button 
          const buttons = allSelected.map((option, index) => {
            const button = document.createElement('button');
            button.classList.add('label');
            button.textContent = option.label;
            button.addEventListener('click', () => {
              container.style.display = 'none';
              prompt.style.display = 'none';
              runContent(index, option.content);
            });
            container.appendChild(button);
            return button;
          });
        });
        // resize lalel text
        let fontSize = 14; // set default font size
        let fits = false;
        while (!fits && fontSize > 8) {
          fits = buttons.every(btn => {
            btn.style.fontSize = fontSize + 'px';
            return btn.scrollWidth <= btn.clientWidth && btn.scrollHeight <= btn.clientHeight;
          });
          if (!fits) fontSize--;
        }
        buttons.forEach(btn => btn.style.fontSize = fontSize + 'px');
      }

      function runContent(index, content) { // display selected content
        // html elements
        document.getElementById('contentCont').style.display = 'flex';
        document.getElementById('contentText').textContent = content;
        // event handling
        document.getElementById('contButton').onclick = () => {
            if (!usedLabels.includes(index)) { // disabled selected options
                usedLabels.push(index);
                const buttons = document.querySelectorAll('#labelGrid button');
                const usedButton = buttons[index];
                usedButton.textContent = '';
                usedButton.disabled = true;
            }
            if (usedLabels.length >= 8) { // generate next grid
                document.getElementById('contentCont').style.display = 'none';
                resetGrid();
            } else { // display grid
                document.getElementById('contentCont').style.display = 'none';
                document.getElementById('labelGrid').style.display = 'grid';
                document.getElementById('promptCont').style.display = 'block';
            }
        };
      }

      function resetGrid() { // reset grid
          if (usedStim.size === 64) {
              runAlert("This is the end of the task.", 3000);
              return;
          } else {
              usedLabels = [];
              gridNum += 1;
              runAlert("New options will now be made available.", 3000, runGrid);
          }
      }
    
    </script>
  </head>
  <body onload="runIntro()">
    <!-- Start Menu -->
    <!-- Task Instructions -->
     <div id="introCont">
        <h1>Task Instructions</h1>
        <p>Sample instructions: In this task you will read short passages describing [insert event or topic of interest]. You will be asked to select the passages you read from a pool of available options.
        <br><br>The task will present 4 screens, each of which will display 16 passage options. The options will be represented by a label indicating the [insert label stimuli] described in the corresponding passage. To select a passage you want to read, click the label using the mouse. Once you select a label, the passage will then be presented for you to read in full. Please ensure you read the passage carefully. Then, click the 'continue' button.
        <br><br>You will <strong>only</strong> be able to read <strong>half</strong> the available passage options on each screen. Once you have read half the available options on the screen, the screen will be refreshed, and new options will be presented.
        <br><br>When you are ready, click the 'Start' button below.</p>
        <button class="start" id="startButton">Start</button>
     </div>
    
    <!-- Grid Page -->
    <div id="labelGrid"></div>
    <div id="promptCont">
      <p>Select an option to continue.</p>
    </div>
    
    <!-- Content Page -->
    <div id="contentCont">
      <div id="contentText"></div>
      <button class="continue" id="contButton">Continue</button>
    </div>
    
    <!-- Alerts -->
    <div id="alertCont"></div>

    <!-- End Page -->
    <div id="endCont">
      <h1>Task End</h1>
      <p>This is the end of task. To return to the demo menu, select the 'End Task' button below.</p>
      <button class="end" id="endButton">End Task</button>
    </div>
    
    </body>
  </html>
  